// This file is generated by rust-protobuf 2.27.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `plug.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_27_1;

#[derive(PartialEq,Clone,Default)]
pub struct PassResult {
    // message fields
    pub username: ::std::string::String,
    pub password: ::std::string::String,
    pub passtype: ::std::string::String,
    pub passfrom: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PassResult {
    fn default() -> &'a PassResult {
        <PassResult as ::protobuf::Message>::default_instance()
    }
}

impl PassResult {
    pub fn new() -> PassResult {
        ::std::default::Default::default()
    }

    // string username = 1;


    pub fn get_username(&self) -> &str {
        &self.username
    }
    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        &mut self.username
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.username, ::std::string::String::new())
    }

    // string password = 2;


    pub fn get_password(&self) -> &str {
        &self.password
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }

    // string passtype = 3;


    pub fn get_passtype(&self) -> &str {
        &self.passtype
    }
    pub fn clear_passtype(&mut self) {
        self.passtype.clear();
    }

    // Param is passed by value, moved
    pub fn set_passtype(&mut self, v: ::std::string::String) {
        self.passtype = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_passtype(&mut self) -> &mut ::std::string::String {
        &mut self.passtype
    }

    // Take field
    pub fn take_passtype(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.passtype, ::std::string::String::new())
    }

    // string passfrom = 4;


    pub fn get_passfrom(&self) -> &str {
        &self.passfrom
    }
    pub fn clear_passfrom(&mut self) {
        self.passfrom.clear();
    }

    // Param is passed by value, moved
    pub fn set_passfrom(&mut self, v: ::std::string::String) {
        self.passfrom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_passfrom(&mut self) -> &mut ::std::string::String {
        &mut self.passfrom
    }

    // Take field
    pub fn take_passfrom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.passfrom, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PassResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.username)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.passtype)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.passfrom)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.username);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.password);
        }
        if !self.passtype.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.passtype);
        }
        if !self.passfrom.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.passfrom);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.username.is_empty() {
            os.write_string(1, &self.username)?;
        }
        if !self.password.is_empty() {
            os.write_string(2, &self.password)?;
        }
        if !self.passtype.is_empty() {
            os.write_string(3, &self.passtype)?;
        }
        if !self.passfrom.is_empty() {
            os.write_string(4, &self.passfrom)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PassResult {
        PassResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "username",
                |m: &PassResult| { &m.username },
                |m: &mut PassResult| { &mut m.username },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "password",
                |m: &PassResult| { &m.password },
                |m: &mut PassResult| { &mut m.password },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "passtype",
                |m: &PassResult| { &m.passtype },
                |m: &mut PassResult| { &mut m.passtype },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "passfrom",
                |m: &PassResult| { &m.passfrom },
                |m: &mut PassResult| { &mut m.passfrom },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PassResult>(
                "PassResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PassResult {
        static instance: ::protobuf::rt::LazyV2<PassResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PassResult::new)
    }
}

impl ::protobuf::Clear for PassResult {
    fn clear(&mut self) {
        self.username.clear();
        self.password.clear();
        self.passtype.clear();
        self.passfrom.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PassResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PassResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PortResult {
    // message fields
    pub host: ::std::string::String,
    pub port: i32,
    pub proto: ::std::string::String,
    pub version: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PortResult {
    fn default() -> &'a PortResult {
        <PortResult as ::protobuf::Message>::default_instance()
    }
}

impl PortResult {
    pub fn new() -> PortResult {
        ::std::default::Default::default()
    }

    // string host = 1;


    pub fn get_host(&self) -> &str {
        &self.host
    }
    pub fn clear_host(&mut self) {
        self.host.clear();
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        &mut self.host
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.host, ::std::string::String::new())
    }

    // int32 port = 2;


    pub fn get_port(&self) -> i32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = v;
    }

    // string proto = 3;


    pub fn get_proto(&self) -> &str {
        &self.proto
    }
    pub fn clear_proto(&mut self) {
        self.proto.clear();
    }

    // Param is passed by value, moved
    pub fn set_proto(&mut self, v: ::std::string::String) {
        self.proto = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proto(&mut self) -> &mut ::std::string::String {
        &mut self.proto
    }

    // Take field
    pub fn take_proto(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.proto, ::std::string::String::new())
    }

    // string version = 4;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PortResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.host)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.port = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.proto)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.host.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.host);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.proto.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.proto);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.version);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.host.is_empty() {
            os.write_string(1, &self.host)?;
        }
        if self.port != 0 {
            os.write_int32(2, self.port)?;
        }
        if !self.proto.is_empty() {
            os.write_string(3, &self.proto)?;
        }
        if !self.version.is_empty() {
            os.write_string(4, &self.version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PortResult {
        PortResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "host",
                |m: &PortResult| { &m.host },
                |m: &mut PortResult| { &mut m.host },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "port",
                |m: &PortResult| { &m.port },
                |m: &mut PortResult| { &mut m.port },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "proto",
                |m: &PortResult| { &m.proto },
                |m: &mut PortResult| { &mut m.proto },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version",
                |m: &PortResult| { &m.version },
                |m: &mut PortResult| { &mut m.version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PortResult>(
                "PortResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PortResult {
        static instance: ::protobuf::rt::LazyV2<PortResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PortResult::new)
    }
}

impl ::protobuf::Clear for PortResult {
    fn clear(&mut self) {
        self.host.clear();
        self.port = 0;
        self.proto.clear();
        self.version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PortResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PortResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HttpResult {
    // message fields
    pub proto: ::std::string::String,
    pub host: ::std::string::String,
    pub port: i32,
    pub title: ::std::string::String,
    pub note: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HttpResult {
    fn default() -> &'a HttpResult {
        <HttpResult as ::protobuf::Message>::default_instance()
    }
}

impl HttpResult {
    pub fn new() -> HttpResult {
        ::std::default::Default::default()
    }

    // string proto = 1;


    pub fn get_proto(&self) -> &str {
        &self.proto
    }
    pub fn clear_proto(&mut self) {
        self.proto.clear();
    }

    // Param is passed by value, moved
    pub fn set_proto(&mut self, v: ::std::string::String) {
        self.proto = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proto(&mut self) -> &mut ::std::string::String {
        &mut self.proto
    }

    // Take field
    pub fn take_proto(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.proto, ::std::string::String::new())
    }

    // string host = 2;


    pub fn get_host(&self) -> &str {
        &self.host
    }
    pub fn clear_host(&mut self) {
        self.host.clear();
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        &mut self.host
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.host, ::std::string::String::new())
    }

    // int32 port = 3;


    pub fn get_port(&self) -> i32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = v;
    }

    // string title = 4;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    // string note = 5;


    pub fn get_note(&self) -> &str {
        &self.note
    }
    pub fn clear_note(&mut self) {
        self.note.clear();
    }

    // Param is passed by value, moved
    pub fn set_note(&mut self, v: ::std::string::String) {
        self.note = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_note(&mut self) -> &mut ::std::string::String {
        &mut self.note
    }

    // Take field
    pub fn take_note(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.note, ::std::string::String::new())
    }
}

impl ::protobuf::Message for HttpResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.proto)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.host)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.port = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.note)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.proto.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.proto);
        }
        if !self.host.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.host);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(3, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.title);
        }
        if !self.note.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.note);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.proto.is_empty() {
            os.write_string(1, &self.proto)?;
        }
        if !self.host.is_empty() {
            os.write_string(2, &self.host)?;
        }
        if self.port != 0 {
            os.write_int32(3, self.port)?;
        }
        if !self.title.is_empty() {
            os.write_string(4, &self.title)?;
        }
        if !self.note.is_empty() {
            os.write_string(5, &self.note)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HttpResult {
        HttpResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "proto",
                |m: &HttpResult| { &m.proto },
                |m: &mut HttpResult| { &mut m.proto },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "host",
                |m: &HttpResult| { &m.host },
                |m: &mut HttpResult| { &mut m.host },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "port",
                |m: &HttpResult| { &m.port },
                |m: &mut HttpResult| { &mut m.port },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &HttpResult| { &m.title },
                |m: &mut HttpResult| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "note",
                |m: &HttpResult| { &m.note },
                |m: &mut HttpResult| { &mut m.note },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HttpResult>(
                "HttpResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HttpResult {
        static instance: ::protobuf::rt::LazyV2<HttpResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HttpResult::new)
    }
}

impl ::protobuf::Clear for HttpResult {
    fn clear(&mut self) {
        self.proto.clear();
        self.host.clear();
        self.port = 0;
        self.title.clear();
        self.note.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HttpResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HttpResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlugResult {
    // message fields
    pub name: ::std::string::String,
    pub args: ::std::string::String,
    pub resulttype: ResultType,
    pub passresult: ::protobuf::RepeatedField<PassResult>,
    pub portresult: ::protobuf::RepeatedField<PortResult>,
    pub httpresult: ::protobuf::RepeatedField<HttpResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlugResult {
    fn default() -> &'a PlugResult {
        <PlugResult as ::protobuf::Message>::default_instance()
    }
}

impl PlugResult {
    pub fn new() -> PlugResult {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string args = 2;


    pub fn get_args(&self) -> &str {
        &self.args
    }
    pub fn clear_args(&mut self) {
        self.args.clear();
    }

    // Param is passed by value, moved
    pub fn set_args(&mut self, v: ::std::string::String) {
        self.args = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_args(&mut self) -> &mut ::std::string::String {
        &mut self.args
    }

    // Take field
    pub fn take_args(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.args, ::std::string::String::new())
    }

    // .ResultType resulttype = 3;


    pub fn get_resulttype(&self) -> ResultType {
        self.resulttype
    }
    pub fn clear_resulttype(&mut self) {
        self.resulttype = ResultType::PASSRET;
    }

    // Param is passed by value, moved
    pub fn set_resulttype(&mut self, v: ResultType) {
        self.resulttype = v;
    }

    // repeated .PassResult passresult = 11;


    pub fn get_passresult(&self) -> &[PassResult] {
        &self.passresult
    }
    pub fn clear_passresult(&mut self) {
        self.passresult.clear();
    }

    // Param is passed by value, moved
    pub fn set_passresult(&mut self, v: ::protobuf::RepeatedField<PassResult>) {
        self.passresult = v;
    }

    // Mutable pointer to the field.
    pub fn mut_passresult(&mut self) -> &mut ::protobuf::RepeatedField<PassResult> {
        &mut self.passresult
    }

    // Take field
    pub fn take_passresult(&mut self) -> ::protobuf::RepeatedField<PassResult> {
        ::std::mem::replace(&mut self.passresult, ::protobuf::RepeatedField::new())
    }

    // repeated .PortResult portresult = 12;


    pub fn get_portresult(&self) -> &[PortResult] {
        &self.portresult
    }
    pub fn clear_portresult(&mut self) {
        self.portresult.clear();
    }

    // Param is passed by value, moved
    pub fn set_portresult(&mut self, v: ::protobuf::RepeatedField<PortResult>) {
        self.portresult = v;
    }

    // Mutable pointer to the field.
    pub fn mut_portresult(&mut self) -> &mut ::protobuf::RepeatedField<PortResult> {
        &mut self.portresult
    }

    // Take field
    pub fn take_portresult(&mut self) -> ::protobuf::RepeatedField<PortResult> {
        ::std::mem::replace(&mut self.portresult, ::protobuf::RepeatedField::new())
    }

    // repeated .HttpResult httpresult = 13;


    pub fn get_httpresult(&self) -> &[HttpResult] {
        &self.httpresult
    }
    pub fn clear_httpresult(&mut self) {
        self.httpresult.clear();
    }

    // Param is passed by value, moved
    pub fn set_httpresult(&mut self, v: ::protobuf::RepeatedField<HttpResult>) {
        self.httpresult = v;
    }

    // Mutable pointer to the field.
    pub fn mut_httpresult(&mut self) -> &mut ::protobuf::RepeatedField<HttpResult> {
        &mut self.httpresult
    }

    // Take field
    pub fn take_httpresult(&mut self) -> ::protobuf::RepeatedField<HttpResult> {
        ::std::mem::replace(&mut self.httpresult, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PlugResult {
    fn is_initialized(&self) -> bool {
        for v in &self.passresult {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.portresult {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.httpresult {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.args)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.resulttype, 3, &mut self.unknown_fields)?
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.passresult)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.portresult)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.httpresult)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.args.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.args);
        }
        if self.resulttype != ResultType::PASSRET {
            my_size += ::protobuf::rt::enum_size(3, self.resulttype);
        }
        for value in &self.passresult {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.portresult {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.httpresult {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.args.is_empty() {
            os.write_string(2, &self.args)?;
        }
        if self.resulttype != ResultType::PASSRET {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.resulttype))?;
        }
        for v in &self.passresult {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.portresult {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.httpresult {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlugResult {
        PlugResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &PlugResult| { &m.name },
                |m: &mut PlugResult| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "args",
                |m: &PlugResult| { &m.args },
                |m: &mut PlugResult| { &mut m.args },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ResultType>>(
                "resulttype",
                |m: &PlugResult| { &m.resulttype },
                |m: &mut PlugResult| { &mut m.resulttype },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PassResult>>(
                "passresult",
                |m: &PlugResult| { &m.passresult },
                |m: &mut PlugResult| { &mut m.passresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PortResult>>(
                "portresult",
                |m: &PlugResult| { &m.portresult },
                |m: &mut PlugResult| { &mut m.portresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HttpResult>>(
                "httpresult",
                |m: &PlugResult| { &m.httpresult },
                |m: &mut PlugResult| { &mut m.httpresult },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlugResult>(
                "PlugResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlugResult {
        static instance: ::protobuf::rt::LazyV2<PlugResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlugResult::new)
    }
}

impl ::protobuf::Clear for PlugResult {
    fn clear(&mut self) {
        self.name.clear();
        self.args.clear();
        self.resulttype = ResultType::PASSRET;
        self.passresult.clear();
        self.portresult.clear();
        self.httpresult.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlugResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlugResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ResultType {
    PASSRET = 0,
    PORTRET = 1,
    HTTPRET = 2,
}

impl ::protobuf::ProtobufEnum for ResultType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ResultType> {
        match value {
            0 => ::std::option::Option::Some(ResultType::PASSRET),
            1 => ::std::option::Option::Some(ResultType::PORTRET),
            2 => ::std::option::Option::Some(ResultType::HTTPRET),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ResultType] = &[
            ResultType::PASSRET,
            ResultType::PORTRET,
            ResultType::HTTPRET,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ResultType>("ResultType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ResultType {
}

impl ::std::default::Default for ResultType {
    fn default() -> Self {
        ResultType::PASSRET
    }
}

impl ::protobuf::reflect::ProtobufValue for ResultType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\nplug.proto\"\x86\x01\n\nPassResult\x12\x1c\n\x08username\x18\x01\x20\
    \x01(\tR\x08usernameB\0\x12\x1c\n\x08password\x18\x02\x20\x01(\tR\x08pas\
    swordB\0\x12\x1c\n\x08passtype\x18\x03\x20\x01(\tR\x08passtypeB\0\x12\
    \x1c\n\x08passfrom\x18\x04\x20\x01(\tR\x08passfromB\0:\0\"n\n\nPortResul\
    t\x12\x14\n\x04host\x18\x01\x20\x01(\tR\x04hostB\0\x12\x14\n\x04port\x18\
    \x02\x20\x01(\x05R\x04portB\0\x12\x16\n\x05proto\x18\x03\x20\x01(\tR\x05\
    protoB\0\x12\x1a\n\x07version\x18\x04\x20\x01(\tR\x07versionB\0:\0\"\x80\
    \x01\n\nHttpResult\x12\x16\n\x05proto\x18\x01\x20\x01(\tR\x05protoB\0\
    \x12\x14\n\x04host\x18\x02\x20\x01(\tR\x04hostB\0\x12\x14\n\x04port\x18\
    \x03\x20\x01(\x05R\x04portB\0\x12\x16\n\x05title\x18\x04\x20\x01(\tR\x05\
    titleB\0\x12\x14\n\x04note\x18\x05\x20\x01(\tR\x04noteB\0:\0\"\xf6\x01\n\
    \nPlugResult\x12\x14\n\x04name\x18\x01\x20\x01(\tR\x04nameB\0\x12\x14\n\
    \x04args\x18\x02\x20\x01(\tR\x04argsB\0\x12-\n\nresulttype\x18\x03\x20\
    \x01(\x0e2\x0b.ResultTypeR\nresulttypeB\0\x12-\n\npassresult\x18\x0b\x20\
    \x03(\x0b2\x0b.PassResultR\npassresultB\0\x12-\n\nportresult\x18\x0c\x20\
    \x03(\x0b2\x0b.PortResultR\nportresultB\0\x12-\n\nhttpresult\x18\r\x20\
    \x03(\x0b2\x0b.HttpResultR\nhttpresultB\0:\0*5\n\nResultType\x12\x0b\n\
    \x07PASSRET\x10\0\x12\x0b\n\x07PORTRET\x10\x01\x12\x0b\n\x07HTTPRET\x10\
    \x02\x1a\0B\0b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
